<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Perabot Megah - Admin Panel</title>
  <link rel="stylesheet" href="css/main.css">
</head>
<body>
  <!-- Toast Container for Floating Notifications -->
  <div id="toastContainer" class="toast-container"></div>
  
  <div class="container">
    <header class="page-header">
      <h1 class="page-title">
        <i class="icon icon-inventory icon-margin-right"></i>
        Perabot Megah - Admin Panel
      </h1>
    </header>
    
    <main class="main-content">
      <!-- Connection Status -->
      <div class="status-section minimal">
        <span class="status-indicator" id="connectionStatus"></span>
        <span id="connectionText">Testing connection...</span>
        <button class="btn btn-tiny" onclick="testConnection()">
          <i class="icon icon-refresh icon-sm"></i>
        </button>
      </div>

      <!-- Receiving Form -->
      <div class="form-section">
        <div class="form-section-header">
          <h3 class="form-section-title">
            <i class="icon icon-add icon-margin-right"></i>
            Receiving - Add New Stock
          </h3>
          
        </div>
        <p>Use this form to record new inventory received from suppliers.</p>
        
        <form id="receivingForm">
          <div class="form-group">
            <label class="form-label" for="sku">Select Product:</label>
            <div class="search-container">
              <input type="text" id="skuInput" name="sku" class="form-input search-input" placeholder="Loading products..." required>
              <button type="button" class="search-clear" onclick="clearSearch()">
                <i class="icon icon-clear"></i>
              </button>
              <div id="searchResults" class="search-results"></div>
            </div>
            <div id="productCount" class="search-info"></div>
            <small class="form-help">Type to search products from Product Master sheet</small>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="quantity">Quantity Received:</label>
            <input type="number" id="quantity" name="quantity" class="form-input" placeholder="Enter quantity" min="1" required>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="destination">Destination Location:</label>
            <div class="location-buttons">
              <button type="button" id="shopBtn" class="location-btn" data-location="Shop">
                <i class="icon icon-store icon-margin-right"></i>
                Shop
              </button>
              <button type="button" id="warehouseBtn" class="location-btn" data-location="Warehouse">
                <i class="icon icon-warehouse icon-margin-right"></i>
                Warehouse
              </button>
            </div>
            <input type="hidden" id="destination" name="destination" required>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="user">User Name:</label>
            <input type="text" id="user" name="user" class="form-input" placeholder="Enter your name" required>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="notes">Notes (Optional):</label>
            <input type="text" id="notes" name="notes" class="form-input" placeholder="Supplier info, quality notes, etc.">
          </div>
          
          <div class="btn-group">
            <button type="submit" id="submitBtn" class="btn btn-success">
              <i class="icon icon-check icon-margin-right"></i>
              Submit Receiving
            </button>
            <button type="button" class="btn btn-outline" onclick="clearReceivingForm()">
              <i class="icon icon-clear icon-margin-right"></i>
              Clear Form
            </button>
          </div>
        </form>
      </div>

      <!-- Transfer Form -->
      <div class="form-section">
        <div class="form-section-header">
          <h3 class="form-section-title">
            <i class="icon icon-swap-horiz icon-margin-right"></i>
            Transfer - Move Stock Between Locations
          </h3>
        </div>
        <p>Use this form to move inventory between Shop and Warehouse locations.</p>
        
        <form id="transferForm">
          <div class="form-group">
            <label class="form-label" for="transferSku">Select Product:</label>
            <div class="search-container">
              <input type="text" id="transferSkuInput" name="transferSku" class="form-input search-input" placeholder="Loading products..." required>
              <button type="button" class="search-clear" onclick="clearTransferSearch()">
                <i class="icon icon-clear"></i>
              </button>
              <div id="transferSearchResults" class="search-results"></div>
            </div>
            <div id="transferProductCount" class="search-info"></div>
            <small class="form-help">Type to search products from Product Master sheet</small>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="transferQuantity">Quantity to Transfer:</label>
            <input type="number" id="transferQuantity" name="transferQuantity" class="form-input" placeholder="Enter quantity" min="1" required>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="transferLocation">Transfer Direction:</label>
            <div class="location-buttons">
              <button type="button" id="transferShopBtn" class="location-btn" data-location="Shop">
                <i class="icon icon-store icon-margin-right"></i>
                Shop → Warehouse
              </button>
              <button type="button" id="transferWarehouseBtn" class="location-btn" data-location="Warehouse">
                <i class="icon icon-warehouse icon-margin-right"></i>
                Warehouse → Shop
              </button>
            </div>
            <input type="hidden" id="transferSource" name="transferSource" required>
            <input type="hidden" id="transferDestination" name="transferDestination" required>
            <div id="transferDirection" class="form-help"></div>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="transferUser">User Name:</label>
            <input type="text" id="transferUser" name="transferUser" class="form-input" placeholder="Enter your name" required>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="transferNotes">Notes (Optional):</label>
            <input type="text" id="transferNotes" name="transferNotes" class="form-input" placeholder="Reason for transfer, special handling, etc.">
          </div>
          
          <div class="btn-group">
            <button type="submit" id="transferSubmitBtn" class="btn btn-success">
              <i class="icon icon-check icon-margin-right"></i>
              Submit Transfer
            </button>
            <button type="button" class="btn btn-outline" onclick="clearTransferForm()">
              <i class="icon icon-clear icon-margin-right"></i>
              Clear Form
            </button>
          </div>
        </form>
      </div>

      <!-- Adjustment Form -->
      <div class="form-section">
        <div class="form-section-header">
          <h3 class="form-section-title">
            <i class="icon icon-adjust icon-margin-right"></i>
            Adjustment - Set Exact Stock Levels
          </h3>
        </div>
        <p>Use this form to correct inventory levels, set exact quantities, or handle stock corrections.</p>
        
        <form id="adjustmentForm">
          <div class="form-group">
            <label class="form-label" for="adjustmentSku">Select Product:</label>
            <div class="search-container">
              <input type="text" id="adjustmentSkuInput" name="adjustmentSku" class="form-input search-input" placeholder="Loading products..." required>
              <button type="button" class="search-clear" onclick="clearAdjustmentSearch()">
                <i class="icon icon-clear"></i>
              </button>
              <div id="adjustmentSearchResults" class="search-results"></div>
            </div>
            <div id="adjustmentProductCount" class="search-info"></div>
            <small class="form-help">Type to search products from Product Master sheet</small>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="adjustmentLocation">Location:</label>
            <div class="location-buttons">
              <button type="button" id="adjustmentShopBtn" class="location-btn" data-location="Shop">
                <i class="icon icon-store icon-margin-right"></i>
                Shop
              </button>
              <button type="button" id="adjustmentWarehouseBtn" class="location-btn" data-location="Warehouse">
                <i class="icon icon-warehouse icon-margin-right"></i>
                Warehouse
              </button>
            </div>
            <input type="hidden" id="adjustmentLocation" name="adjustmentLocation" required>
          </div>
          
          <!-- Current Stock Display - positioned between location and new stock level -->
          <div id="currentStockDisplay" class="current-stock-display" style="display: none;">
            <div id="currentStockLoading" class="current-stock-loading" style="display: none;">
              <div class="loading-spinner-small"></div>
              <span>Loading current stock...</span>
            </div>
            <div id="currentStockContent" class="current-stock-content" style="display: none;">
              <i class="icon icon-info icon-sm icon-margin-right"></i>
              <span>Current stock: <strong id="currentStockValue">0</strong> at <strong id="currentStockLocation">Shop</strong></span>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="adjustmentQuantity">New Stock Level:</label>
            <input type="number" id="adjustmentQuantity" name="adjustmentQuantity" class="form-input" placeholder="Enter exact quantity" min="0" required>
            <small class="form-help">Enter the exact quantity you want to set.</small>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="adjustmentUser">User Name:</label>
            <input type="text" id="adjustmentUser" name="adjustmentUser" class="form-input" placeholder="Enter your name" required>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="adjustmentNotes">Reason for Adjustment (Required):</label>
            <input type="text" id="adjustmentNotes" name="adjustmentNotes" class="form-input" placeholder="Stock count, damage, loss, correction, etc." required>
            <small class="form-help">Please provide a clear reason for this adjustment.</small>
          </div>
          
          <div class="btn-group">
            <button type="submit" id="adjustmentSubmitBtn" class="btn btn-success">
              <i class="icon icon-check icon-margin-right"></i>
              Submit Adjustment
            </button>
            <button type="button" class="btn btn-outline" onclick="clearAdjustmentForm()">
              <i class="icon icon-clear icon-margin-right"></i>
              Clear Form
            </button>
          </div>
        </form>
      </div>

      <!-- Sales Form -->
      <div class="form-section">
        <div class="form-section-header">
          <h3 class="form-section-title">
            <i class="icon icon-remove icon-margin-right"></i>
            Sales - Record Product Sales
          </h3>
        </div>
        <p>Use this form to record multiple product sales at once.</p>
        
        <form id="salesForm">
          <!-- Batch-level fields -->
          <div class="form-group">
            <label class="form-label" for="salesUser">User Name:</label>
            <input type="text" id="salesUser" name="salesUser" class="form-input" placeholder="Enter your name" required>
          </div>
          
          <div class="form-group">
            <label class="form-label" for="salesNotes">Sale Details (Optional):</label>
            <input type="text" id="salesNotes" name="salesNotes" class="form-input" placeholder="Customer info, payment method, special notes, etc.">
            <small class="form-help">Optional: Additional details about the sale</small>
            <div class="sales-channel-buttons sales-channel-buttons-desktop">
              <button type="button" class="btn btn-pill" onclick="fillSalesDetails('Shopee')">Shopee</button>
              <button type="button" class="btn btn-pill" onclick="fillSalesDetails('Lazada')">Lazada</button>
              <button type="button" class="btn btn-pill" onclick="fillSalesDetails('Tiktok')">Tiktok</button>
              <button type="button" class="btn btn-pill" onclick="fillSalesDetails('Live')">Live</button>
              <button type="button" class="btn btn-pill" onclick="fillSalesDetails('Website')">Website</button>
            </div>
            <div class="sales-channel-buttons sales-channel-buttons-mobile">
              <button type="button" class="btn btn-pill" onclick="fillSalesDetails('Shopee')">Shopee</button>
              <button type="button" class="btn btn-pill" onclick="fillSalesDetails('Lazada')">Lazada</button>
              <button type="button" class="btn btn-pill" onclick="fillSalesDetails('Tiktok')">Tiktok</button>
              <button type="button" class="btn btn-pill" onclick="fillSalesDetails('Live')">Live</button>
              <button type="button" class="btn btn-pill" onclick="fillSalesDetails('Website')">Website</button>
            </div>
          </div>
          
          <!-- Input row for adding records -->
          <div class="form-group">
            <label class="form-label">Add Sales Record:</label>
            <div class="sales-input-row">
              <div class="sales-input-group">
                <label class="form-label-small" for="salesSkuInput">Product:</label>
                <div class="search-container">
                  <input type="text" id="salesSkuInput" name="salesSku" class="form-input search-input" placeholder="Loading products...">
                  <button type="button" class="search-clear" onclick="clearSalesSearch()">
                    <i class="icon icon-clear"></i>
                  </button>
                  <div id="salesSearchResults" class="search-results"></div>
                </div>
                <div id="salesProductCount" class="search-info"></div>
              </div>
              
              <div class="sales-input-group">
                <label class="form-label-small" for="salesQuantity">Quantity:</label>
                <input type="number" id="salesQuantity" name="salesQuantity" class="form-input" placeholder="Qty" min="1">
                <div class="search-info" style="visibility: hidden;">&nbsp;</div>
              </div>
              
              <div class="sales-input-group">
                <label class="form-label-small">&nbsp;</label>
                <button type="button" id="addSalesRecordBtn" class="btn btn-primary" onclick="addSalesRecord()">
                  <i class="icon icon-add icon-margin-right"></i>
                  Add to Table
                </button>
                <div class="search-info" style="visibility: hidden;">&nbsp;</div>
              </div>
            </div>
            <small class="form-help">Search for a product, enter quantity, then click "Add to Table"</small>
          </div>
          
          <!-- Dynamic table for sales records -->
          <div id="salesRecordsTable" class="sales-records-table" style="display: none;">
            <h4 class="table-title">Sales Records to Submit</h4>
            <table class="sales-table">
              <thead>
                <tr>
                  <th>SKU</th>
                  <th class="product-name-column">Product Name</th>
                  <th>Quantity</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="salesRecordsTableBody">
                <!-- Dynamic rows will be added here -->
              </tbody>
            </table>
          </div>
          
          <!-- Submit buttons -->
          <div class="btn-group">
            <button type="submit" id="salesSubmitBtn" class="btn btn-success" disabled>
              <i class="icon icon-check icon-margin-right"></i>
              Submit All Sales
            </button>
            <button type="button" class="btn btn-outline" onclick="clearSalesForm()">
              <i class="icon icon-clear icon-margin-right"></i>
              Clear All
            </button>
          </div>
        </form>
      </div>

      <!-- Results Display (for auto-conversion to toasts) -->
      <div id="receivingResult"></div>
      
      <!-- Quick Inventory Check -->
      <div class="form-section">
        <div class="form-section-header">
          <h3 class="form-section-title">
            <i class="icon icon-inventory icon-margin-right"></i>
            Quick Inventory Check
          </h3>
          <div class="form-section-actions">
            <button class="btn btn-primary" onclick="loadSnapshot()">
              <i class="icon icon-refresh icon-margin-right"></i>
              Refresh Inventory
            </button>
            <button class="btn btn-outline" onclick="clearSnapshot()">
              <i class="icon icon-clear icon-margin-right"></i>
              Clear Display
            </button>
          </div>
        </div>
        <div id="snapshotTable"></div>
      </div>
    </main>
  </div>

  <script>
    // Configuration
    const apiBase = "https://script.google.com/macros/s/AKfycbxWJtUf1RbkfZ5WYzduPCenebrqAbBAw20XbzCLtjs4FXH7k9Gsuyrpu4zm1Ycu2iG0/exec";

    // ====== Toast Notification System ======
    
    // Centralized toast function that automatically handles all message types
    function showToast(type, title, message, duration = 5000) {
      const toastContainer = document.getElementById('toastContainer');
      
      // Create toast element
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      
      // Build a dedupe key from type+title+message
      const key = `${type}|${title}|${message}`;
      toast.setAttribute('data-toast-key', key);
      
      // If a toast with the same key already exists, reuse it (no duplicate)
      const existing = toastContainer.querySelector(`.toast[data-toast-key="${CSS.escape(key)}"]`);
      if (existing) {
        return existing;
      }
      
      // Get appropriate icon for type
      let iconClass = 'icon-info';
      switch(type) {
        case 'success': iconClass = 'icon-check-circle'; break;
        case 'error': iconClass = 'icon-error'; break;
        case 'warning': iconClass = 'icon-warning'; break;
        case 'info': iconClass = 'icon-info'; break;
      }
      
      toast.innerHTML = `
        <i class="icon ${iconClass} toast-icon"></i>
        <div class="toast-content">
          <span class="toast-message">${message}</span>
        </div>
      `;
      
      // Cap number of toasts to 3 (remove the oldest first)
      while (toastContainer.children.length >= 3) {
        toastContainer.removeChild(toastContainer.firstElementChild);
      }
      
      // Add to container
      toastContainer.appendChild(toast);
      
      // Trigger show animation
      setTimeout(() => toast.classList.add('show'), 10);
      
      // Auto-hide after duration
      if (duration > 0) {
        setTimeout(() => {
          toast.classList.add('hide');
          setTimeout(() => {
            if (toast.parentElement) {
              toast.remove();
            }
          }, 200);
        }, duration);
      }
      
      return toast;
    }
    
    // Simple convenience functions that only show toasts (no result div updates)
    function showSuccess(message, duration = 5000) {
      return showToast('success', '', message, duration);
    }
    
    function showError(message, duration = 5000) {
      return showToast('error', '', message, duration);
    }
    
    function showWarning(message, duration = 5000) {
      return showToast('warning', '', message, duration);
    }
    
    function showInfo(message, duration = 5000) {
      return showToast('info', '', message, duration);
    }
    


    // Initialize page
    document.addEventListener('DOMContentLoaded', function() {
      testConnection();
      setupReceivingForm();
      loadAllProducts(); // Load products once for all sections
      setupProductSearch();
      setupLocationButtons();
      setupTransferForm(); // Initialize transfer form
      setupTransferProductSearch(); // Initialize transfer product search
      setupTransferLocationButtons(); // Initialize transfer location buttons
      setupAdjustmentForm(); // Initialize adjustment form
      setupAdjustmentProductSearch(); // Initialize adjustment product search
      setupAdjustmentLocationButtons(); // Initialize adjustment location buttons
      setupSalesForm(); // Initialize sales form
      setupSalesProductSearch(); // Initialize sales product search
    });



    // ====== Connection Testing ======
    function testConnection() {
      const statusIndicator = document.getElementById('connectionStatus');
      const statusText = document.getElementById('connectionText');
      
      statusIndicator.className = 'status-indicator';
      statusText.textContent = 'Testing connection...';
      
      fetch(apiBase + "?action=getInventorySnapshot")
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          return response.json();
        })
        .then(data => {
          if (data.status === "success") {
            statusIndicator.className = 'status-indicator status-online';
            statusText.textContent = 'Connected successfully! Web app is responding.';
          } else {
            throw new Error(data.message || 'Unknown error from web app');
          }
        })
        .catch(error => {
          statusIndicator.className = 'status-indicator status-offline';
          statusText.textContent = 'Connection failed: ' + error.message;
          showError(error.message, 5000);
          console.error('Connection test failed:', error);
        });
    }

    // Global variable to store all products
    let allProducts = [];

    // ====== Products Loading ======
    function loadAllProducts() {
      // Get all search inputs and product count displays
      const searchInputs = [
        { input: document.getElementById('skuInput'), countDiv: document.getElementById('productCount') },
        { input: document.getElementById('transferSkuInput'), countDiv: document.getElementById('transferProductCount') },
        { input: document.getElementById('adjustmentSkuInput'), countDiv: document.getElementById('adjustmentProductCount') },
        { input: document.getElementById('salesSkuInput'), countDiv: document.getElementById('salesProductCount') }
      ];
      
      // Set all inputs to loading state
      searchInputs.forEach(({ input, countDiv }) => {
        if (input && countDiv) {
          input.placeholder = 'Loading products...';
          input.disabled = true;
        }
      });
      
      // Single API call to get products
      fetch(apiBase + "?action=getProducts")
        .then(response => response.json())
        .then(data => {
          if (data.status === "success" && data.data && data.data.length > 0) {
            allProducts = data.data; // Store all products globally
            
            // Update all sections with success state
            searchInputs.forEach(({ input, countDiv }) => {
              if (input && countDiv) {
                input.placeholder = 'Search by SKU or product name...';
                countDiv.textContent = `Loaded ${allProducts.length} products`;
                input.disabled = false;
              }
            });
            
            // success: keep silent to reduce notification noise
          } else {
            // Update all sections with no data state
            searchInputs.forEach(({ input, countDiv }) => {
              if (input && countDiv) {
                input.placeholder = 'No products available';
                countDiv.textContent = 'No products available';
                input.disabled = false;
              }
            });
            console.error('Failed to load products:', data.message || 'Unknown error');
          }
        })
        .catch(error => {
          // Update all sections with error state
          searchInputs.forEach(({ input, countDiv }) => {
            if (input && countDiv) {
              input.placeholder = 'Error loading products';
              countDiv.textContent = 'Error loading products';
              input.disabled = false;
            }
          });
          showError('Failed to load products. Please refresh the page.', 5000);
          console.error('Failed to load products:', error);
        });
    }

    function showSearchResults(products, searchTerm, minScore = 0, totalMatches = 0, totalProducts = 0) {
      const searchResults = document.getElementById('searchResults');
      const productCountDiv = document.getElementById('productCount');
      
      if (!products || products.length === 0) {
        searchResults.innerHTML = `
          <div class="search-results-empty">
            <div class="mb-2">No high-relevance products found</div>
            <div class="text-xs text-tertiary">
              Minimum score: ${minScore}<br>
              ${totalMatches > 0 ? `${totalMatches} products matched but were below threshold<br>` : ''}
              Try a more specific search term
            </div>
          </div>
        `;
        productCountDiv.textContent = totalMatches > 0 
          ? `No results above minimum score ${minScore} (${totalMatches} low-relevance matches filtered out)`
          : `No results above minimum score ${minScore}`;
      } else {
        searchResults.innerHTML = '';
        
        products.forEach(product => {
          const resultItem = document.createElement('div');
          resultItem.className = 'search-result-item';
          
          // Highlight matched parts in SKU and name
          const highlightedSku = highlightMatches(product.sku, searchTerm);
          const highlightedName = highlightMatches(product.displayName, searchTerm);
          
          // Color-code the relevance score
          let scoreColor = 'var(--color-text-tertiary)';
          if (product.score >= 80) scoreColor = 'var(--color-success)'; // Green for high relevance
          else if (product.score >= 50) scoreColor = 'var(--color-warning)'; // Orange for medium relevance
          else if (product.score >= 20) scoreColor = 'var(--color-info)'; // Blue for low relevance
          
          resultItem.innerHTML = `
            <div class="font-semibold">${highlightedSku}</div>
            <div class="text-sm text-secondary">${highlightedName}</div>
            <div class="text-xs font-medium" style="color: ${scoreColor}; margin-top: var(--spacing-xs);">
              Relevance: ${product.score} ${product.score >= 80 ? '⭐' : product.score >= 50 ? '✨' : '•'}
            </div>
          `;
          
          resultItem.addEventListener('click', () => {
            selectProduct(product);
          });
          
          resultItem.addEventListener('mouseenter', () => {
            resultItem.style.backgroundColor = 'var(--color-bg-tertiary)';
          });
          
          resultItem.addEventListener('mouseleave', () => {
            resultItem.style.backgroundColor = 'var(--color-bg-primary)';
          });
          
          searchResults.appendChild(resultItem);
        });
        
        // Update product count display with score information
        if (products === allProducts) {
          productCountDiv.textContent = `Showing all ${products.length} products`;
        } else {
          const filteredOut = totalMatches - products.length;
          const filterInfo = filteredOut > 0 ? ` (${filteredOut} low-relevance results filtered out)` : '';
          productCountDiv.textContent = `Showing ${products.length} high-relevance results (min score: ${minScore})${filterInfo}`;
        }
      }
      
      searchResults.style.display = 'block';
    }

    function highlightMatches(text, searchTerm) {
      if (!searchTerm || !text) return text;
      
      const searchLower = searchTerm.toLowerCase();
      const textLower = text.toLowerCase();
      
      // Find all matches (case-insensitive)
      const matches = [];
      let index = 0;
      while ((index = textLower.indexOf(searchLower, index)) !== -1) {
        matches.push({ start: index, end: index + searchLower.length });
        index += 1;
      }
      
      // If no exact matches, try fuzzy highlighting
      if (matches.length === 0) {
        return highlightFuzzyMatches(text, searchTerm);
      }
      
      // Highlight exact matches
      let highlightedText = '';
      let lastEnd = 0;
      
      matches.forEach(match => {
        highlightedText += text.substring(lastEnd, match.start);
        highlightedText += `<span style="background-color: var(--color-warning-light); font-weight: bold;">${text.substring(match.start, match.end)}</span>`;
        lastEnd = match.end;
      });
      
      highlightedText += text.substring(lastEnd);
      return highlightedText;
    }

    function highlightFuzzyMatches(text, searchTerm) {
      if (!searchTerm || !text) return text;
      
      const searchLower = searchTerm.toLowerCase();
      const textLower = text.toLowerCase();
      
      let highlightedText = '';
      let searchIndex = 0;
      
      for (let i = 0; i < text.length && searchIndex < searchTerm.length; i++) {
        if (textLower[i] === searchLower[searchIndex]) {
          highlightedText += `<span style="background-color: var(--color-info-light); font-weight: bold;">${text[i]}</span>`;
          searchIndex++;
        } else {
          highlightedText += text[i];
        }
      }
      
      highlightedText += text.substring(highlightedText.replace(/<[^>]*>/g, '').length);
      return highlightedText;
    }

    function selectProduct(product) {
      const skuInput = document.getElementById('skuInput');
      const searchResults = document.getElementById('searchResults');
      
      skuInput.value = product.sku;
      searchResults.style.display = 'none';
      
      console.log(`Selected product: ${product.sku} - ${product.displayName}`);
    }

    function selectTransferProduct(product) {
      const transferSkuInput = document.getElementById('transferSkuInput');
      const transferSearchResults = document.getElementById('transferSearchResults');
      
      transferSkuInput.value = product.sku;
      transferSearchResults.style.display = 'none';
      
      console.log(`Selected transfer product: ${product.sku} - ${product.displayName}`);
    }

    function clearSearch() {
      const skuInput = document.getElementById('skuInput');
      skuInput.value = '';
      hideSearchResults();
    }

    // ====== Location Button Functionality ======
    function setupLocationButtons() {
      const shopBtn = document.getElementById('shopBtn');
      const warehouseBtn = document.getElementById('warehouseBtn');
      const destinationInput = document.getElementById('destination');
      
      // Add click event listeners
      shopBtn.addEventListener('click', () => selectLocation('Shop', shopBtn, warehouseBtn));
      warehouseBtn.addEventListener('click', () => selectLocation('Warehouse', warehouseBtn, shopBtn));
      
      // Set default selection (Shop)
      selectLocation('Shop', shopBtn, warehouseBtn);
    }

    function setupTransferLocationButtons() {
      const transferShopBtn = document.getElementById('transferShopBtn');
      const transferWarehouseBtn = document.getElementById('transferWarehouseBtn');
      const transferSourceInput = document.getElementById('transferSource');
      const transferDestinationInput = document.getElementById('transferDestination');
      const transferDirectionDiv = document.getElementById('transferDirection');
      
      // Add click event listeners for source location
      transferShopBtn.addEventListener('click', () => {
        selectTransferSourceLocation('Shop', transferShopBtn, transferWarehouseBtn);
      });
      transferWarehouseBtn.addEventListener('click', () => {
        selectTransferSourceLocation('Warehouse', transferWarehouseBtn, transferShopBtn);
      });
      
      // Set default selection (Shop → Warehouse)
      selectTransferSourceLocation('Shop', transferShopBtn, transferWarehouseBtn);
    }

    function selectLocation(location, selectedBtn, otherBtn) {
      const destinationInput = document.getElementById('destination');
      
      // Update hidden input value
      destinationInput.value = location;
      
      // Update button styles
      selectedBtn.classList.add('active');
      otherBtn.classList.remove('active');
      
      console.log(`Selected destination: ${location}`);
    }

    function selectTransferSourceLocation(location, selectedBtn, otherBtn) {
      const transferSourceInput = document.getElementById('transferSource');
      const transferDestinationInput = document.getElementById('transferDestination');
      const transferDirectionDiv = document.getElementById('transferDirection');
      
      // Update hidden input values
      transferSourceInput.value = location;
      
      // Automatically set destination to the opposite location
      const destinationLocation = location === 'Shop' ? 'Warehouse' : 'Shop';
      transferDestinationInput.value = destinationLocation;
      
      // Update direction display
      transferDirectionDiv.textContent = `From: ${location} → To: ${destinationLocation}`;
      
      // Update button styles
      selectedBtn.classList.add('active');
      otherBtn.classList.remove('active');
      
      console.log(`Selected transfer: ${location} → ${destinationLocation}`);
    }

    function selectTransferDestLocation(location, selectedBtn, otherBtn) {
      // This function is no longer needed since destination is auto-filled
      // Keeping it for compatibility but it won't be called
      console.log('selectTransferDestLocation called but not needed in simplified interface');
    }

    // ====== Product Search Functionality ======
    function setupProductSearch() {
      const skuInput = document.getElementById('skuInput');
      
      // Add event listener for search input
      skuInput.addEventListener('input', function() {
        if (this.value.trim() === '') {
          hideSearchResults();
          return;
        }
        filterProducts(this.value);
      });
      
      // Keyboard navigation
      skuInput.addEventListener('keydown', function(e) {
        const searchResults = document.getElementById('searchResults');
        const visibleItems = searchResults.querySelectorAll('.search-result-item');
        
        if (visibleItems.length === 0) return;
        
        let currentIndex = -1;
        visibleItems.forEach((item, index) => {
          if (item.classList.contains('selected')) {
            currentIndex = index;
          }
        });
        
        switch(e.key) {
          case 'ArrowDown':
            e.preventDefault();
            if (currentIndex < visibleItems.length - 1) {
              if (currentIndex >= 0) visibleItems[currentIndex].classList.remove('selected');
              visibleItems[currentIndex + 1].classList.add('selected');
            }
            break;
          case 'ArrowUp':
            e.preventDefault();
            if (currentIndex > 0) {
              visibleItems[currentIndex].classList.remove('selected');
              visibleItems[currentIndex - 1].classList.add('selected');
            }
            break;
          case 'Enter':
            e.preventDefault();
            if (currentIndex >= 0) {
              const selectedProduct = allProducts.find(p => 
                p.sku === visibleItems[currentIndex].querySelector('div').textContent.replace(/<[^>]*>/g, '')
              );
              if (selectedProduct) selectProduct(selectedProduct);
            }
            break;
          case 'Escape':
            hideSearchResults();
            skuInput.blur();
            break;
        }
      });
      
      // Hide search results when clicking outside
      document.addEventListener('click', function(e) {
        const searchContainer = document.getElementById('skuInput').parentElement;
        if (!searchContainer.contains(e.target)) {
          hideSearchResults();
        }
      });
      
      // Show all products when input is focused and empty
      skuInput.addEventListener('focus', function() {
        if (this.value.trim() === '') {
          showSearchResults(allProducts);
        }
      });
    }

    function filterProducts(searchTerm) {
      if (!searchTerm || searchTerm.trim() === '') {
        hideSearchResults();
        return;
      }
      
      const searchLower = searchTerm.toLowerCase();
      
      // Score each product based on fuzzy matching
      const scoredProducts = allProducts.map(product => {
        const skuLower = product.sku.toLowerCase();
        const nameLower = product.displayName.toLowerCase();
        
        let score = 0;
        let bestScore = 0;
        
        // Check SKU matching
        const skuScore = calculateFuzzyScore(searchLower, skuLower);
        score += skuScore * 2; // SKU gets higher weight
        bestScore = Math.max(bestScore, skuScore);
        
        // Check product name matching
        const nameScore = calculateFuzzyScore(searchLower, nameLower);
        score += nameScore;
        bestScore = Math.max(bestScore, nameScore);
        
        // Bonus for exact matches
        if (skuLower === searchLower) score += 100;
        if (nameLower === searchLower) score += 50;
        
        // Bonus for starts with
        if (skuLower.startsWith(searchLower)) score += 30;
        if (nameLower.startsWith(searchLower)) score += 20;
        
        // Bonus for contains
        if (skuLower.includes(searchLower)) score += 10;
        if (nameLower.includes(searchLower)) score += 5;
        
        return { ...product, score, bestScore };
      });
      
      // Filter products with high relevance scores and sort by score
      const minScore = 90; // Fixed high-quality threshold
      const filteredProducts = scoredProducts
        .filter(product => product.score >= minScore)
        .sort((a, b) => b.score - a.score);
      
      // Get total count of products that matched (including low scores)
      const totalMatches = scoredProducts.filter(product => product.score > 0).length;
      
      // Show all results above the threshold (no artificial limit)
      showSearchResults(filteredProducts, searchTerm, minScore, totalMatches, scoredProducts.length);
    }

    function calculateFuzzyScore(searchTerm, targetText) {
      if (!searchTerm || !targetText) return 0;
      
      const searchLen = searchTerm.length;
      const targetLen = targetText.length;
      
      // Exact match gets highest score
      if (searchTerm === targetText) return 100;
      
      // Starts with gets high score
      if (targetText.startsWith(searchTerm)) return 80;
      
      // Contains gets medium score
      if (targetText.includes(searchTerm)) return 60;
      
      // Fuzzy matching using character sequence
      let score = 0;
      let searchIndex = 0;
      let consecutiveMatches = 0;
      let lastMatchIndex = -1;
      
      for (let i = 0; i < targetLen && searchIndex < searchLen; i++) {
        if (targetText[i].toLowerCase() === searchTerm[searchIndex].toLowerCase()) {
          // Bonus for consecutive matches
          if (lastMatchIndex === i - 1) {
            consecutiveMatches++;
            score += consecutiveMatches * 2;
          } else {
            consecutiveMatches = 1;
          }
          
          // Bonus for early matches
          score += (targetLen - i) / targetLen * 10;
          
          lastMatchIndex = i;
          searchIndex++;
        }
      }
      
      // If we found all characters in sequence
      if (searchIndex === searchLen) {
        score += 40;
        
        // Bonus for shorter gaps between characters
        const gaps = [];
        let lastFound = -1;
        for (let i = 0; i < targetLen; i++) {
          if (targetText[i].toLowerCase() === searchTerm[searchIndex - 1].toLowerCase()) {
            if (lastFound !== -1) {
              gaps.push(i - lastFound);
            }
            lastFound = i;
          }
        }
        
        if (gaps.length > 0) {
          const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
          score += Math.max(0, 20 - avgGap);
        }
      }
      
      // Penalty for very long target text
      if (targetLen > searchLen * 3) {
        score *= 0.8;
      }
      
      return Math.round(score);
    }

    function hideSearchResults() {
      const searchResults = document.getElementById('searchResults');
      searchResults.style.display = 'none';
    }

    // ====== Receiving Form Setup ======
    function setupReceivingForm() {
      const form = document.getElementById('receivingForm');
      form.addEventListener('submit', handleReceivingSubmit);
    }

    function handleReceivingSubmit(e) {
      e.preventDefault();
      
      const formData = new FormData(e.target);
      const data = {
        sku: formData.get('sku'),
        quantity: parseInt(formData.get('quantity')),
        mode: 'RECEIVING',
        source: 'Supplier',
        destination: formData.get('destination'),
        user: formData.get('user'),
        notes: formData.get('notes') || ''
      };

      submitReceiving(data);
    }

    function submitReceiving(data) {
      const submitBtn = document.getElementById('submitBtn');
      
      submitBtn.disabled = true;
      
      const params = new URLSearchParams({
        action: 'addInventoryLog',
        data: JSON.stringify([data])
      });

      fetch(apiBase + '?' + params.toString(), {
        method: 'GET'
      })
      .then(response => response.json())
      .then(result => {
        if (result.status === 'success') {
          showSuccess(
            `Received ${data.quantity} ${data.sku.split('-')[0]}... at ${data.destination}`
          );
          clearReceivingForm();
          loadSnapshot(); // Refresh inventory display
        } else {
          throw new Error(result.message || 'Unknown error occurred');
        }
      })
      .catch(error => {
        showError(
          'Error',
          `${error.message}<br><small>Please try again or contact support if the problem persists.</small>`
        );
        console.error('Receiving submission failed:', error);
      })
      .finally(() => {
        submitBtn.disabled = false;
      });
    }

    function clearReceivingForm() {
      document.getElementById('receivingForm').reset();
      
      // Reset location buttons to default (Shop)
      const shopBtn = document.getElementById('shopBtn');
      const warehouseBtn = document.getElementById('warehouseBtn');
      selectLocation('Shop', shopBtn, warehouseBtn);
      
      // silent
    }

    // ====== Inventory Snapshot ======
    function loadSnapshot() {
      const tableDiv = document.getElementById('snapshotTable');
      tableDiv.innerHTML = '<div class="loading-enhanced"><div class="loading-spinner"></div>Loading inventory...</div>';
      
      fetch(apiBase + "?action=getInventorySnapshot")
        .then(response => response.json())
        .then(data => {
          if (data.status === "success" && data.data && data.data.length > 0) {
            displaySnapshot(data.data);
          } else {
            tableDiv.innerHTML = '<div class="alert alert-error"><i class="icon icon-error icon-margin-right"></i>No inventory data available</div>';
          }
        })
        .catch(error => {
          tableDiv.innerHTML = `<div class="alert alert-error"><i class="icon icon-error icon-margin-right"></i>Error loading inventory: ${error.message}</div>`;
          showError(`Failed to load inventory: ${error.message}`);
          console.error('Failed to load snapshot:', error);
        });
    }

    function displaySnapshot(data) {
      const tableDiv = document.getElementById('snapshotTable');
      
      if (data.length === 0) {
        tableDiv.innerHTML = '<div class="alert alert-info"><i class="icon icon-info icon-margin-right"></i>No inventory data available</div>';
        return;
      }

      const headers = data[0];
      const rows = data.slice(1);
      
      let html = '<table class="w-full" style="border-collapse: collapse; margin-top: var(--spacing-md);">';
      
      // Headers
      html += '<thead><tr>';
      headers.forEach(header => {
        html += `<th style="border: 1px solid var(--color-border-light); padding: var(--spacing-md); background-color: var(--color-bg-tertiary); text-align: left; font-weight: var(--font-weight-semibold);">${header}</th>`;
      });
      html += '</tr></thead>';
      
      // Rows
      html += '<tbody>';
      rows.forEach(row => {
        html += '<tr>';
        row.forEach(cell => {
          html += `<td style="border: 1px solid var(--color-border-light); padding: var(--spacing-md);">${cell}</td>`;
        });
        html += '</tr>';
      });
      html += '</tbody></table>';
      
      tableDiv.innerHTML = html;
    }

    function clearSnapshot() {
      document.getElementById('snapshotTable').innerHTML = '';
      
      // silent
    }

    // ====== Transfer Form Setup ======
    function setupTransferForm() {
      const transferForm = document.getElementById('transferForm');
      transferForm.addEventListener('submit', handleTransferSubmit);
    }

    function handleTransferSubmit(e) {
      e.preventDefault();
      
      const formData = new FormData(e.target);
      const data = {
        sku: formData.get('transferSku'),
        quantity: parseInt(formData.get('transferQuantity')),
        mode: 'TRANSFER',
        source: formData.get('transferSource'),
        destination: formData.get('transferDestination'),
        user: formData.get('transferUser'),
        notes: formData.get('transferNotes') || ''
      };

      submitTransfer(data);
    }

    function submitTransfer(data) {
      const transferSubmitBtn = document.getElementById('transferSubmitBtn');
      
      transferSubmitBtn.disabled = true;
      
      const params = new URLSearchParams({
        action: 'addInventoryLog',
        data: JSON.stringify([data])
      });

      fetch(apiBase + '?' + params.toString(), {
        method: 'GET'
      })
      .then(response => response.json())
      .then(result => {
        if (result.status === 'success') {
          showSuccess(
            `Moved ${data.quantity} ${data.sku.split('-')[0]}... to ${data.destination}`
          );
          clearTransferForm();
          loadSnapshot(); // Refresh inventory display
        } else {
          throw new Error(result.message || 'Unknown error occurred');
        }
      })
      .catch(error => {
        showError(
          'Error',
          `${error.message}<br><small>Please try again or contact support if the problem persists.</small>`
        );
        console.error('Transfer submission failed:', error);
      })
      .finally(() => {
        transferSubmitBtn.disabled = false;
      });
    }

    function clearTransferForm() {
      document.getElementById('transferForm').reset();
      
      // Reset location buttons to default (Shop → Warehouse)
      const transferShopBtn = document.getElementById('transferShopBtn');
      const transferWarehouseBtn = document.getElementById('transferWarehouseBtn');
      selectTransferSourceLocation('Shop', transferShopBtn, transferWarehouseBtn);
      
      // Clear direction display
      const transferDirectionDiv = document.getElementById('transferDirection');
      transferDirectionDiv.textContent = 'From: Shop → To: Warehouse';
      
      // silent
    }

    function showTransferSearchResults(products, searchTerm, minScore = 0, totalMatches = 0, totalProducts = 0) {
      const transferSearchResults = document.getElementById('transferSearchResults');
      const transferProductCountDiv = document.getElementById('transferProductCount');
      
      if (!products || products.length === 0) {
        transferSearchResults.innerHTML = `
          <div class="search-results-empty">
            <div class="mb-2">No high-relevance products found</div>
            <div class="text-xs text-tertiary">
              Minimum score: ${minScore}<br>
              ${totalMatches > 0 ? `${totalMatches} products matched but were below threshold<br>` : ''}
              Try a more specific search term
            </div>
          </div>
        `;
        transferProductCountDiv.textContent = totalMatches > 0 
          ? `No results above minimum score ${minScore} (${totalMatches} low-relevance matches filtered out)`
          : `No results above minimum score ${minScore}`;
      } else {
        transferSearchResults.innerHTML = '';
        
        products.forEach(product => {
          const resultItem = document.createElement('div');
          resultItem.className = 'search-result-item';
          
          // Highlight matched parts in SKU and name
          const highlightedSku = highlightMatches(product.sku, searchTerm);
          const highlightedName = highlightMatches(product.displayName, searchTerm);
          
          // Color-code the relevance score
          let scoreColor = 'var(--color-text-tertiary)';
          if (product.score >= 80) scoreColor = 'var(--color-success)'; // Green for high relevance
          else if (product.score >= 50) scoreColor = 'var(--color-warning)'; // Orange for medium relevance
          else if (product.score >= 20) scoreColor = 'var(--color-info)'; // Blue for low relevance
          
          resultItem.innerHTML = `
            <div class="font-semibold">${highlightedSku}</div>
            <div class="text-sm text-secondary">${highlightedName}</div>
            <div class="text-xs font-medium" style="color: ${scoreColor}; margin-top: var(--spacing-xs);">
              Relevance: ${product.score} ${product.score >= 80 ? '⭐' : product.score >= 50 ? '✨' : '•'}
            </div>
          `;
          
          resultItem.addEventListener('click', () => {
            selectTransferProduct(product);
          });
          
          resultItem.addEventListener('mouseenter', () => {
            resultItem.style.backgroundColor = 'var(--color-bg-tertiary)';
          });
          
          resultItem.addEventListener('mouseleave', () => {
            resultItem.style.backgroundColor = 'var(--color-bg-primary)';
          });
          
          transferSearchResults.appendChild(resultItem);
        });
        
        // Update product count display with score information
        if (products === allProducts) {
          transferProductCountDiv.textContent = `Showing all ${products.length} products`;
        } else {
          const filteredOut = totalMatches - products.length;
          const filterInfo = filteredOut > 0 ? ` (${filteredOut} low-relevance results filtered out)` : '';
          transferProductCountDiv.textContent = `Showing ${products.length} high-relevance results (min score: ${minScore})${filterInfo}`;
        }
      }
      
      transferSearchResults.style.display = 'block';
    }

    function filterTransferProducts(searchTerm) {
      if (!searchTerm || searchTerm.trim() === '') {
        hideTransferSearchResults();
        return;
      }
      
      const searchLower = searchTerm.toLowerCase();
      
      // Score each product based on fuzzy matching
      const scoredProducts = allProducts.map(product => {
        const skuLower = product.sku.toLowerCase();
        const nameLower = product.displayName.toLowerCase();
        
        let score = 0;
        let bestScore = 0;
        
        // Check SKU matching
        const skuScore = calculateFuzzyScore(searchLower, skuLower);
        score += skuScore * 2; // SKU gets higher weight
        bestScore = Math.max(bestScore, skuScore);
        
        // Check product name matching
        const nameScore = calculateFuzzyScore(searchLower, nameLower);
        score += nameScore;
        bestScore = Math.max(bestScore, nameScore);
        
        // Bonus for exact matches
        if (skuLower === searchLower) score += 100;
        if (nameLower === searchLower) score += 50;
        
        // Bonus for starts with
        if (skuLower.startsWith(searchLower)) score += 30;
        if (nameLower.startsWith(searchLower)) score += 20;
        
        // Bonus for contains
        if (skuLower.includes(searchLower)) score += 10;
        if (nameLower.includes(searchLower)) score += 5;
        
        return { ...product, score, bestScore };
      });
      
      // Filter products with high relevance scores and sort by score
      const minScore = 90; // Fixed high-quality threshold
      const filteredProducts = scoredProducts
        .filter(product => product.score >= minScore)
        .sort((a, b) => b.score - a.score);
      
      // Get total count of products that matched (including low scores)
      const totalMatches = scoredProducts.filter(product => product.score > 0).length;
      
      // Show all results above the threshold (no artificial limit)
      showTransferSearchResults(filteredProducts, searchTerm, minScore, totalMatches, scoredProducts.length);
    }

    function clearTransferSearch() {
      const transferSkuInput = document.getElementById('transferSkuInput');
      transferSkuInput.value = '';
      hideTransferSearchResults();
    }

    function setupTransferProductSearch() {
      const transferSkuInput = document.getElementById('transferSkuInput');
      
      // Add event listener for search input
      transferSkuInput.addEventListener('input', function() {
        if (this.value.trim() === '') {
          hideTransferSearchResults();
          return;
        }
        filterTransferProducts(this.value);
      });
      
      // Keyboard navigation
      transferSkuInput.addEventListener('keydown', function(e) {
        const transferSearchResults = document.getElementById('transferSearchResults');
        const visibleItems = transferSearchResults.querySelectorAll('.search-result-item');
        
        if (visibleItems.length === 0) return;
        
        let currentIndex = -1;
        visibleItems.forEach((item, index) => {
          if (item.classList.contains('selected')) {
            currentIndex = index;
          }
        });
        
        switch(e.key) {
          case 'ArrowDown':
            e.preventDefault();
            if (currentIndex < visibleItems.length - 1) {
              if (currentIndex >= 0) visibleItems[currentIndex].classList.remove('selected');
              visibleItems[currentIndex + 1].classList.add('selected');
            }
            break;
          case 'ArrowUp':
            e.preventDefault();
            if (currentIndex > 0) {
              visibleItems[currentIndex].classList.remove('selected');
              visibleItems[currentIndex - 1].classList.add('selected');
            }
            break;
          case 'Enter':
            e.preventDefault();
            if (currentIndex >= 0) {
              const selectedProduct = allProducts.find(p => 
                p.sku === visibleItems[currentIndex].querySelector('div').textContent.replace(/<[^>]*>/g, '')
              );
              if (selectedProduct) selectTransferProduct(selectedProduct);
            }
            break;
          case 'Escape':
            hideTransferSearchResults();
            transferSkuInput.blur();
            break;
        }
      });
      
      // Hide search results when clicking outside
      document.addEventListener('click', function(e) {
        const searchContainer = document.getElementById('transferSkuInput').parentElement;
        if (!searchContainer.contains(e.target)) {
          hideTransferSearchResults();
        }
      });
      
      // Show all products when input is focused and empty
      transferSkuInput.addEventListener('focus', function() {
        if (this.value.trim() === '') {
          showTransferSearchResults(allProducts);
        }
      });
    }

    function hideTransferSearchResults() {
      const transferSearchResults = document.getElementById('transferSearchResults');
      transferSearchResults.style.display = 'none';
    }

    function showAdjustmentSearchResults(products, searchTerm, minScore = 0, totalMatches = 0, totalProducts = 0) {
      const adjustmentSearchResults = document.getElementById('adjustmentSearchResults');
      const adjustmentProductCountDiv = document.getElementById('adjustmentProductCount');
      
      if (!products || products.length === 0) {
        adjustmentSearchResults.innerHTML = `
          <div class="search-results-empty">
            <div class="mb-2">No high-relevance products found</div>
            <div class="text-xs text-tertiary">
              Minimum score: ${minScore}<br>
              ${totalMatches > 0 ? `${totalMatches} products matched but were below threshold<br>` : ''}
              Try a more specific search term
            </div>
          </div>
        `;
        adjustmentProductCountDiv.textContent = totalMatches > 0 
          ? `No results above minimum score ${minScore} (${totalMatches} low-relevance matches filtered out)`
          : `No results above minimum score ${minScore}`;
      } else {
        adjustmentSearchResults.innerHTML = '';
        
        products.forEach(product => {
          const resultItem = document.createElement('div');
          resultItem.className = 'search-result-item';
          
          // Highlight matched parts in SKU and name
          const highlightedSku = highlightMatches(product.sku, searchTerm);
          const highlightedName = highlightMatches(product.displayName, searchTerm);
          
          // Color-code the relevance score
          let scoreColor = 'var(--color-text-tertiary)';
          if (product.score >= 80) scoreColor = 'var(--color-success)'; // Green for high relevance
          else if (product.score >= 50) scoreColor = 'var(--color-warning)'; // Orange for medium relevance
          else if (product.score >= 20) scoreColor = 'var(--color-info)'; // Blue for low relevance
          
          resultItem.innerHTML = `
            <div class="font-semibold">${highlightedSku}</div>
            <div class="text-sm text-secondary">${highlightedName}</div>
            <div class="text-xs font-medium" style="color: ${scoreColor}; margin-top: var(--spacing-xs);">
              Relevance: ${product.score} ${product.score >= 80 ? '⭐' : product.score >= 50 ? '✨' : '•'}
            </div>
          `;
          
          resultItem.addEventListener('click', () => {
            selectAdjustmentProduct(product);
          });
          
          resultItem.addEventListener('mouseenter', () => {
            resultItem.style.backgroundColor = 'var(--color-bg-tertiary)';
          });
          
          resultItem.addEventListener('mouseleave', () => {
            resultItem.style.backgroundColor = 'var(--color-bg-primary)';
          });
          
          adjustmentSearchResults.appendChild(resultItem);
        });
        
        // Update product count display with score information
        if (products === allProducts) {
          adjustmentProductCountDiv.textContent = `Showing all ${products.length} products`;
        } else {
          const filteredOut = totalMatches - products.length;
          const filterInfo = filteredOut > 0 ? ` (${filteredOut} low-relevance results filtered out)` : '';
          adjustmentProductCountDiv.textContent = `Showing ${products.length} high-relevance results (min score: ${minScore})${filterInfo}`;
        }
      }
      
      adjustmentSearchResults.style.display = 'block';
    }

    function clearAdjustmentSearch() {
      const adjustmentSkuInput = document.getElementById('adjustmentSkuInput');
      adjustmentSkuInput.value = '';
      hideAdjustmentSearchResults();
    }

    // ====== Adjustment Form Setup ======
    function setupAdjustmentForm() {
      const adjustmentForm = document.getElementById('adjustmentForm');
      adjustmentForm.addEventListener('submit', handleAdjustmentSubmit);
    }

    function handleAdjustmentSubmit(e) {
      e.preventDefault();
      
      const formData = new FormData(e.target);
      const data = {
        sku: formData.get('adjustmentSku'),
        quantity: parseInt(formData.get('adjustmentQuantity')),
        mode: 'ADJUSTMENT',
        source: formData.get('adjustmentLocation'), // Source is the location being adjusted
        destination: formData.get('adjustmentLocation'), // Destination is the location being adjusted
        user: formData.get('adjustmentUser'),
        notes: formData.get('adjustmentNotes') || ''
      };

      submitAdjustment(data);
    }

    function submitAdjustment(data) {
      const adjustmentSubmitBtn = document.getElementById('adjustmentSubmitBtn');
      
      adjustmentSubmitBtn.disabled = true;
      
      const params = new URLSearchParams({
        action: 'addInventoryLog',
        data: JSON.stringify([data])
      });

      fetch(apiBase + '?' + params.toString(), {
        method: 'GET'
      })
      .then(response => response.json())
      .then(result => {
        if (result.status === 'success') {
          showSuccess(
            `Set ${data.quantity} ${data.sku.split('-')[0]}... at ${data.source}`
          );
          clearAdjustmentForm();
          loadSnapshot(); // Refresh inventory display
        } else {
          throw new Error(result.message || 'Unknown error occurred');
        }
      })
      .catch(error => {
        showError(
          'Error',
          `${error.message}<br><small>Please try again or contact support if the problem persists.</small>`
        );
        console.error('Adjustment submission failed:', error);
      })
      .finally(() => {
        adjustmentSubmitBtn.disabled = false;
      });
    }

    function clearAdjustmentForm() {
      document.getElementById('adjustmentForm').reset();
      
      // Reset location buttons to default (Shop)
      const adjustmentShopBtn = document.getElementById('adjustmentShopBtn');
      const adjustmentWarehouseBtn = document.getElementById('adjustmentWarehouseBtn');
      selectAdjustmentLocation('Shop', adjustmentShopBtn, adjustmentWarehouseBtn);
      
      // Hide current stock display and all its states
      const currentStockDisplay = document.getElementById('currentStockDisplay');
      const currentStockLoading = document.getElementById('currentStockLoading');
      const currentStockContent = document.getElementById('currentStockContent');
      
      currentStockDisplay.style.display = 'none';
      currentStockLoading.style.display = 'none';
      currentStockContent.style.display = 'none';
      
      // silent
    }

    function setupAdjustmentProductSearch() {
      const adjustmentSkuInput = document.getElementById('adjustmentSkuInput');
      
      // Add event listener for search input
      adjustmentSkuInput.addEventListener('input', function() {
        if (this.value.trim() === '') {
          hideAdjustmentSearchResults();
          return;
        }
        filterAdjustmentProducts(this.value);
      });
      
      // Keyboard navigation
      adjustmentSkuInput.addEventListener('keydown', function(e) {
        const adjustmentSearchResults = document.getElementById('adjustmentSearchResults');
        const visibleItems = adjustmentSearchResults.querySelectorAll('.search-result-item');
        
        if (visibleItems.length === 0) return;
        
        let currentIndex = -1;
        visibleItems.forEach((item, index) => {
          if (item.classList.contains('selected')) {
            currentIndex = index;
          }
        });
        
        switch(e.key) {
          case 'ArrowDown':
            e.preventDefault();
            if (currentIndex < visibleItems.length - 1) {
              if (currentIndex >= 0) visibleItems[currentIndex].classList.remove('selected');
              visibleItems[currentIndex + 1].classList.add('selected');
            }
            break;
          case 'ArrowUp':
            e.preventDefault();
            if (currentIndex > 0) {
              visibleItems[currentIndex].classList.remove('selected');
              visibleItems[currentIndex - 1].classList.add('selected');
            }
            break;
          case 'Enter':
            e.preventDefault();
            if (currentIndex >= 0) {
              const selectedProduct = allProducts.find(p => 
                p.sku === visibleItems[currentIndex].querySelector('div').textContent.replace(/<[^>]*>/g, '')
              );
              if (selectedProduct) selectAdjustmentProduct(selectedProduct);
            }
            break;
          case 'Escape':
            hideAdjustmentSearchResults();
            adjustmentSkuInput.blur();
            break;
        }
      });
      
      // Hide search results when clicking outside
      document.addEventListener('click', function(e) {
        const searchContainer = document.getElementById('adjustmentSkuInput').parentElement;
        if (!searchContainer.contains(e.target)) {
          hideAdjustmentSearchResults();
        }
      });
      
      // Show all products when input is focused and empty
      adjustmentSkuInput.addEventListener('focus', function() {
        if (this.value.trim() === '') {
          showAdjustmentSearchResults(allProducts);
        }
      });
    }

    function filterAdjustmentProducts(searchTerm) {
      if (!searchTerm || searchTerm.trim() === '') {
        hideAdjustmentSearchResults();
        return;
      }
      
      const searchLower = searchTerm.toLowerCase();
      
      // Score each product based on fuzzy matching
      const scoredProducts = allProducts.map(product => {
        const skuLower = product.sku.toLowerCase();
        const nameLower = product.displayName.toLowerCase();
        
        let score = 0;
        let bestScore = 0;
        
        // Check SKU matching
        const skuScore = calculateFuzzyScore(searchLower, skuLower);
        score += skuScore * 2; // SKU gets higher weight
        bestScore = Math.max(bestScore, skuScore);
        
        // Check product name matching
        const nameScore = calculateFuzzyScore(searchLower, nameLower);
        score += nameScore;
        bestScore = Math.max(bestScore, nameScore);
        
        // Bonus for exact matches
        if (skuLower === searchLower) score += 100;
        if (nameLower === searchLower) score += 50;
        
        // Bonus for starts with
        if (skuLower.startsWith(searchLower)) score += 30;
        if (nameLower.startsWith(searchLower)) score += 20;
        
        // Bonus for contains
        if (skuLower.includes(searchLower)) score += 10;
        if (nameLower.includes(searchLower)) score += 5;
        
        return { ...product, score, bestScore };
      });
      
      // Filter products with high relevance scores and sort by score
      const minScore = 90; // Fixed high-quality threshold
      const filteredProducts = scoredProducts
        .filter(product => product.score >= minScore)
        .sort((a, b) => b.score - a.score);
      
      // Get total count of products that matched (including low scores)
      const totalMatches = scoredProducts.filter(product => product.score > 0).length;
      
      // Show all results above the threshold (no artificial limit)
      showAdjustmentSearchResults(filteredProducts, searchTerm, minScore, totalMatches, scoredProducts.length);
    }

    function selectAdjustmentProduct(product) {
      const adjustmentSkuInput = document.getElementById('adjustmentSkuInput');
      const adjustmentSearchResults = document.getElementById('adjustmentSearchResults');
      
      adjustmentSkuInput.value = product.sku;
      adjustmentSearchResults.style.display = 'none';
      
      // Check if we have both SKU and location to show current stock
      checkAndShowCurrentStock();
      
      console.log(`Selected adjustment product: ${product.sku} - ${product.displayName}`);
    }

    function hideAdjustmentSearchResults() {
      const adjustmentSearchResults = document.getElementById('adjustmentSearchResults');
      adjustmentSearchResults.style.display = 'none';
    }

    // Function to check and show current stock for adjustment
    function checkAndShowCurrentStock() {
      const sku = document.getElementById('adjustmentSkuInput').value;
      const location = document.getElementById('adjustmentLocation').value;
      const currentStockDisplay = document.getElementById('currentStockDisplay');
      const currentStockLoading = document.getElementById('currentStockLoading');
      const currentStockContent = document.getElementById('currentStockContent');
      const currentStockValue = document.getElementById('currentStockValue');
      const currentStockLocation = document.getElementById('currentStockLocation');
      
      if (sku && location) {
        // Update location display
        currentStockLocation.textContent = location;
        
        // Show loading state
        currentStockDisplay.style.display = 'block';
        currentStockLoading.style.display = 'flex';
        currentStockContent.style.display = 'none';
        
        // Fetch current inventory to get stock level
        fetch(apiBase + "?action=getInventorySnapshot")
          .then(response => response.json())
          .then(data => {
            if (data.status === "success" && data.data && data.data.length > 1) {
              const headers = data.data[0];
              const rows = data.data.slice(1);
              
              // Find the SKU and location columns
              const skuIndex = headers.findIndex(h => h.toLowerCase().includes('sku'));
              const locationIndex = headers.findIndex(h => h.toLowerCase().includes('location'));
              const quantityIndex = headers.findIndex(h => h.toLowerCase().includes('quantity') || h.toLowerCase().includes('stock'));
              
              if (skuIndex !== -1 && locationIndex !== -1 && quantityIndex !== -1) {
                // Find the row with matching SKU and location
                const matchingRow = rows.find(row => 
                  row[skuIndex] === sku && row[locationIndex] === location
                );
                
                if (matchingRow) {
                  const currentStock = matchingRow[quantityIndex] || 0;
                  currentStockValue.textContent = currentStock;
                } else {
                  currentStockValue.textContent = '0';
                }
              } else {
                currentStockValue.textContent = 'N/A';
              }
              
              // Hide loading, show content
              currentStockLoading.style.display = 'none';
              currentStockContent.style.display = 'flex';
            } else {
              currentStockValue.textContent = 'N/A';
              currentStockLoading.style.display = 'none';
              currentStockContent.style.display = 'flex';
            }
          })
          .catch(error => {
            console.error('Failed to fetch current stock:', error);
            currentStockValue.textContent = 'N/A';
            currentStockLoading.style.display = 'none';
            currentStockContent.style.display = 'flex';
          });
      } else {
        currentStockDisplay.style.display = 'none';
      }
    }

    function setupAdjustmentLocationButtons() {
      const adjustmentShopBtn = document.getElementById('adjustmentShopBtn');
      const adjustmentWarehouseBtn = document.getElementById('adjustmentWarehouseBtn');
      const adjustmentLocationInput = document.getElementById('adjustmentLocation');
      
      // Add click event listeners
      adjustmentShopBtn.addEventListener('click', () => selectAdjustmentLocation('Shop', adjustmentShopBtn, adjustmentWarehouseBtn));
      adjustmentWarehouseBtn.addEventListener('click', () => selectAdjustmentLocation('Warehouse', adjustmentWarehouseBtn, adjustmentShopBtn));
      
      // Set default selection (Shop)
      selectAdjustmentLocation('Shop', adjustmentShopBtn, adjustmentWarehouseBtn);
    }

    function selectAdjustmentLocation(location, selectedBtn, otherBtn) {
      const adjustmentLocationInput = document.getElementById('adjustmentLocation');
      
      // Update hidden input value
      adjustmentLocationInput.value = location;
      
      // Update button styles
      selectedBtn.classList.add('active');
      otherBtn.classList.remove('active');
      
      // Check if we have both SKU and location to show current stock
      checkAndShowCurrentStock();
      
      console.log(`Selected adjustment location: ${location}`);
    }

    // ====== Sales Form Setup ======
    function setupSalesForm() {
      const salesForm = document.getElementById('salesForm');
      salesForm.addEventListener('submit', handleSalesSubmit);
    }



    function submitBulkSales(bulkData) {
      const salesSubmitBtn = document.getElementById('salesSubmitBtn');
      
      salesSubmitBtn.disabled = true;
      
      const params = new URLSearchParams({
        action: 'addInventoryLog',
        data: JSON.stringify(bulkData)
      });

      fetch(apiBase + '?' + params.toString(), {
        method: 'GET'
      })
      .then(response => response.json())
      .then(result => {
        if (result.status === 'success') {
          showSuccess(
            'Bulk Sales Submitted Successfully!',
            `Total Records: ${bulkData.length}<br>User: ${bulkData[0].user}<br><small>All inventory and sales snapshots updated automatically</small>`
          );
          clearSalesForm();
          loadSnapshot(); // Refresh inventory display
        } else {
          throw new Error(result.message || 'Unknown error occurred');
        }
      })
      .catch(error => {
        showError(
          'Error',
          `${error.message}<br><small>Please try again or contact support if the problem persists.</small>`
        );
        console.error('Bulk sales submission failed:', error);
      })
      .finally(() => {
        salesSubmitBtn.disabled = false;
      });
    }

    function clearSalesForm() {
      document.getElementById('salesForm').reset();
    }

    function showSalesSearchResults(products, searchTerm, minScore = 0, totalMatches = 0, totalProducts = 0) {
      const salesSearchResults = document.getElementById('salesSearchResults');
      const salesProductCountDiv = document.getElementById('salesProductCount');
      
      if (!products || products.length === 0) {
        salesSearchResults.innerHTML = `
          <div class="search-results-empty">
            <div class="mb-2">No high-relevance products found</div>
            <div class="text-xs text-tertiary">
              Minimum score: ${minScore}<br>
              ${totalMatches > 0 ? `${totalMatches} products matched but were below threshold<br>` : ''}
              Try a more specific search term
            </div>
          </div>
        `;
        salesProductCountDiv.textContent = totalMatches > 0 
          ? `No results above minimum score ${minScore} (${totalMatches} low-relevance matches filtered out)`
          : `No results above minimum score ${minScore}`;
      } else {
        salesSearchResults.innerHTML = '';
        
        products.forEach(product => {
          const resultItem = document.createElement('div');
          resultItem.className = 'search-result-item';
          
          // Highlight matched parts in SKU and name
          const highlightedSku = highlightMatches(product.sku, searchTerm);
          const highlightedName = highlightMatches(product.displayName, searchTerm);
          
          // Color-code the relevance score
          let scoreColor = 'var(--color-text-tertiary)';
          if (product.score >= 80) scoreColor = 'var(--color-success)'; // Green for high relevance
          else if (product.score >= 50) scoreColor = 'var(--color-warning)'; // Orange for medium relevance
          else if (product.score >= 20) scoreColor = 'var(--color-info)'; // Blue for low relevance
          
          resultItem.innerHTML = `
            <div class="font-semibold">${highlightedSku}</div>
            <div class="text-sm text-secondary">${highlightedName}</div>
            <div class="text-xs font-medium" style="color: ${scoreColor}; margin-top: var(--spacing-xs);">
              Relevance: ${product.score} ${product.score >= 80 ? '⭐' : product.score >= 50 ? '✨' : '•'}
            </div>
          `;
          
          resultItem.addEventListener('click', () => {
            selectSalesProduct(product);
          });
          
          resultItem.addEventListener('mouseenter', () => {
            resultItem.style.backgroundColor = 'var(--color-bg-tertiary)';
          });
          
          resultItem.addEventListener('mouseleave', () => {
            resultItem.style.backgroundColor = 'var(--color-bg-primary)';
          });
          
          salesSearchResults.appendChild(resultItem);
        });
        
        // Update product count display with score information
        if (products === allProducts) {
          salesProductCountDiv.textContent = `Showing all ${products.length} products`;
        } else {
          const filteredOut = totalMatches - products.length;
          const filterInfo = filteredOut > 0 ? ` (${filteredOut} low-relevance results filtered out)` : '';
          salesProductCountDiv.textContent = `Showing ${products.length} high-relevance results (min score: ${minScore})${filterInfo}`;
        }
      }
      
      salesSearchResults.style.display = 'block';
    }

    function filterSalesProducts(searchTerm) {
      if (!searchTerm || searchTerm.trim() === '') {
        hideSalesSearchResults();
        return;
      }
      
      const searchLower = searchTerm.toLowerCase();
      
      // Score each product based on fuzzy matching
      const scoredProducts = allProducts.map(product => {
        const skuLower = product.sku.toLowerCase();
        const nameLower = product.displayName.toLowerCase();
        
        let score = 0;
        let bestScore = 0;
        
        // Check SKU matching
        const skuScore = calculateFuzzyScore(searchLower, skuLower);
        score += skuScore * 2; // SKU gets higher weight
        bestScore = Math.max(bestScore, skuScore);
        
        // Check product name matching
        const nameScore = calculateFuzzyScore(searchLower, nameLower);
        score += nameScore;
        bestScore = Math.max(bestScore, nameScore);
        
        // Bonus for exact matches
        if (skuLower === searchLower) score += 100;
        if (nameLower === searchLower) score += 50;
        
        // Bonus for starts with
        if (skuLower.startsWith(searchLower)) score += 30;
        if (nameLower.startsWith(searchLower)) score += 20;
        
        // Bonus for contains
        if (skuLower.includes(searchLower)) score += 10;
        if (nameLower.includes(searchLower)) score += 5;
        
        return { ...product, score, bestScore };
      });
      
      // Filter products with high relevance scores and sort by score
      const minScore = 90; // Fixed high-quality threshold
      const filteredProducts = scoredProducts
        .filter(product => product.score >= minScore)
        .sort((a, b) => b.score - a.score);
      
      // Get total count of products that matched (including low scores)
      const totalMatches = scoredProducts.filter(product => product.score > 0).length;
      
      // Show all results above the threshold (no artificial limit)
      showSalesSearchResults(filteredProducts, searchTerm, minScore, totalMatches, scoredProducts.length);
    }

    function clearSalesSearch() {
      const salesSkuInput = document.getElementById('salesSkuInput');
      salesSkuInput.value = '';
      hideSalesSearchResults();
    }

    function selectSalesProduct(product) {
      const salesSkuInput = document.getElementById('salesSkuInput');
      const salesSearchResults = document.getElementById('salesSearchResults');
      
      salesSkuInput.value = product.sku;
      salesSearchResults.style.display = 'none';
      
      console.log(`Selected sales product: ${product.sku} - ${product.displayName}`);
    }

    function setupSalesProductSearch() {
      const salesSkuInput = document.getElementById('salesSkuInput');
      
      // Add event listener for search input
      salesSkuInput.addEventListener('input', function() {
        if (this.value.trim() === '') {
          hideSalesSearchResults();
          return;
        }
        filterSalesProducts(this.value);
      });
      
      // Keyboard navigation
      salesSkuInput.addEventListener('keydown', function(e) {
        const salesSearchResults = document.getElementById('salesSearchResults');
        const visibleItems = salesSearchResults.querySelectorAll('.search-result-item');
        
        if (visibleItems.length === 0) return;
        
        let currentIndex = -1;
        visibleItems.forEach((item, index) => {
          if (item.classList.contains('selected')) {
            currentIndex = index;
          }
        });
        
        switch(e.key) {
          case 'ArrowDown':
            e.preventDefault();
            if (currentIndex < visibleItems.length - 1) {
              if (currentIndex >= 0) visibleItems[currentIndex].classList.remove('selected');
              visibleItems[currentIndex + 1].classList.add('selected');
            }
            break;
          case 'ArrowUp':
            e.preventDefault();
            if (currentIndex > 0) {
              visibleItems[currentIndex].classList.remove('selected');
              visibleItems[currentIndex - 1].classList.add('selected');
            }
            break;
          case 'Enter':
            e.preventDefault();
            if (currentIndex >= 0) {
              const selectedProduct = allProducts.find(p => 
                p.sku === visibleItems[currentIndex].querySelector('div').textContent.replace(/<[^>]*>/g, '')
              );
              if (selectedProduct) selectSalesProduct(selectedProduct);
            }
            break;
          case 'Escape':
            hideSalesSearchResults();
            salesSkuInput.blur();
            break;
        }
      });
      
      // Hide search results when clicking outside
      document.addEventListener('click', function(e) {
        const searchContainer = document.getElementById('salesSkuInput').parentElement;
        if (!searchContainer.contains(e.target)) {
          hideSalesSearchResults();
        }
      });
      
      // Show all products when input is focused and empty
      salesSkuInput.addEventListener('focus', function() {
        if (this.value.trim() === '') {
          showSalesSearchResults(allProducts);
        }
      });
    }

    function hideSalesSearchResults() {
      const salesSearchResults = document.getElementById('salesSearchResults');
      salesSearchResults.style.display = 'none';
    }

    // ====== Sales Channel Buttons ======
    function fillSalesDetails(channel) {
      const salesNotesInput = document.getElementById('salesNotes');
      const currentValue = salesNotesInput.value.trim();
      
      // If there's already content, append the channel with a separator
      if (currentValue) {
        salesNotesInput.value = currentValue + ' | ' + channel;
      } else {
        salesNotesInput.value = channel;
      }
      
      // Focus the input for easy editing
      salesNotesInput.focus();
      
      // silent
      
      console.log(`Filled sales details with channel: ${channel}`);
    }

    // ====== Sales Records Table Management ======
    let salesRecords = []; // Global array to store sales records

    function addSalesRecord() {
      const skuInput = document.getElementById('salesSkuInput');
      const quantityInput = document.getElementById('salesQuantity');
      const sku = skuInput.value.trim();
      const quantity = parseInt(quantityInput.value);
      
      // Validation
      if (!sku) {
        alert('Please select a product');
        return;
      }
      
      if (!quantity || quantity <= 0) {
        alert('Please enter a valid quantity');
        return;
      }
      
      // Check if SKU already exists in table
      if (salesRecords.some(record => record.sku === sku)) {
        alert('This product is already in the table. Please use a different product or adjust the existing quantity.');
        return;
      }
      
      // Find product details from allProducts
      const product = allProducts.find(p => p.sku === sku);
      if (!product) {
        alert('Product not found');
        return;
      }
      
      // Add to records array
      const newRecord = {
        sku: sku,
        productName: product.displayName,
        quantity: quantity
      };
      
      salesRecords.push(newRecord);
      
      // Update table display
      updateSalesRecordsTable();
      
      // Clear input fields
      skuInput.value = '';
      quantityInput.value = '';
      hideSalesSearchResults();
      
      // Focus back to SKU input for next entry
      skuInput.focus();
      
      // silent
      
      console.log(`Added sales record: ${sku} - ${quantity}`);
    }

    function removeSalesRecord(index) {
      const removedRecord = salesRecords[index];
      salesRecords.splice(index, 1);
      updateSalesRecordsTable();
      
      // Show success toast
      showInfo('Removed', `${removedRecord.productName} removed from sales table`, 2000);
      
      console.log(`Removed sales record at index ${index}`);
    }

    function updateSalesRecordsTable() {
      const tableContainer = document.getElementById('salesRecordsTable');
      const tableBody = document.getElementById('salesRecordsTableBody');
      const submitBtn = document.getElementById('salesSubmitBtn');
      
      if (salesRecords.length === 0) {
        // Hide table when empty
        tableContainer.style.display = 'none';
        submitBtn.disabled = true;
        return;
      }
      
      // Show table and enable submit button
      tableContainer.style.display = 'block';
      submitBtn.disabled = false;
      
      // Clear existing rows
      tableBody.innerHTML = '';
      
      // Add new rows
      salesRecords.forEach((record, index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td class="sku-column">${record.sku}</td>
          <td class="product-name-column">
            <div class="product-name">${record.productName}</div>
          </td>
          <td class="quantity-column">${record.quantity}</td>
          <td class="actions-column">
            <button type="button" class="delete-record-btn" onclick="removeSalesRecord(${index})" title="Remove this record">
              <i class="icon icon-delete"></i>
            </button>
          </td>
        `;
        tableBody.appendChild(row);
      });
    }

    function clearSalesForm() {
      // Clear batch fields
      document.getElementById('salesUser').value = '';
      document.getElementById('salesNotes').value = '';
      
      // Clear input fields
      document.getElementById('salesSkuInput').value = '';
      document.getElementById('salesQuantity').value = '';
      hideSalesSearchResults();
      
      // Clear table
      salesRecords = [];
      updateSalesRecordsTable();
      
      // silent
      
      console.log('Sales form cleared');
    }

    // Override the existing handleSalesSubmit function
    function handleSalesSubmit(e) {
      e.preventDefault();
      
      if (salesRecords.length === 0) {
        alert('Please add at least one sales record before submitting');
        return;
      }
      
      const user = document.getElementById('salesUser').value.trim();
      const notes = document.getElementById('salesNotes').value.trim();
      
      if (!user) {
        alert('Please enter your name');
        return;
      }
      
      // Prepare bulk data
      const bulkData = salesRecords.map(record => ({
        sku: record.sku,
        quantity: record.quantity,
        mode: 'SALE',
        source: 'Shop',
        destination: 'Customer',
        user: user,
        notes: notes || ''
      }));
      
      console.log('Submitting bulk sales data:', bulkData);
      submitBulkSales(bulkData);
    }

    function submitBulkSales(bulkData) {
      const salesSubmitBtn = document.getElementById('salesSubmitBtn');
      salesSubmitBtn.disabled = true;
      
      const params = new URLSearchParams({
        action: 'addInventoryLog',
        data: JSON.stringify(bulkData)
      });

      fetch(apiBase + '?' + params.toString(), {
        method: 'GET'
      })
      .then(response => response.json())
      .then(result => {
        if (result.status === 'success') {
          showSuccess(
            `${bulkData.length} sales recorded`
          );
          clearSalesForm();
          loadSnapshot(); // Refresh inventory display
        } else {
          throw new Error(result.message || 'Unknown error occurred');
        }
      })
      .catch(error => {
        showError(
          'Error',
          error.message
        );
        console.error('Bulk sales submission failed:', error);
      })
      .finally(() => {
        salesSubmitBtn.disabled = false;
      });
    }
  </script>
</body>
</html>
